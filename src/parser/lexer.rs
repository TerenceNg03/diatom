use std::str::Chars;

use super::error::{ErrorReporter, ErrorType, FileLocation, LineLocation};

/// A enumerate of all tokens possibly generated by [Lexer][crate::parser::lexer::Lexer].
#[cfg_attr(test, derive(Debug))]
pub enum Token {
    Unknown,
    NewLine,
    Str(String),
    Integer(i64),
    Float(f64),
    Id(String),
    Key(Keyword),
    Op(Operator),
}

/// A enum of all keywords
#[cfg_attr(test, derive(Debug))]
pub enum Keyword {
    TRUE,
    FALSE,
    DO,
    END,
    IF,
    THEN,
    ELSE,
    CASE,
    IN,
    FOR,
    NIL,
    ASSERT,
    RETURN,
    BREAK,
    CONTINUE,
}

/// A enum of all operators
#[cfg_attr(test, derive(Debug))]
pub enum Operator {
    Plus,
    Minus,
    Exp,
    Mul,
    DivFloor,
    Div,
    Mod,
    Range,
    And,
    Or,
    Not,
    GT,
    GE,
    EQ,
    NE,
    LT,
    LE,
    Assign,
    Comma,
}

struct FileIterator<'a> {
    location: LineLocation,
    iterator: Chars<'a>,
}

impl<'a> FileIterator<'a> {
    fn new(file_content: &'a str) -> Self {
        Self {
            location: LineLocation::new(0, 0, 0),
            iterator: file_content.chars(),
        }
    }

    /// Return next character. Useful to lookahead.
    fn peek(&self) -> Option<char> {
        let mut iter = self.iterator.clone();
        iter.next()
    }

    /// Return current location's clone.
    fn get_location(&self) -> LineLocation {
        self.location.clone()
    }
}

impl<'a> Iterator for FileIterator<'a> {
    type Item = char;
    fn next(&mut self) -> Option<Self::Item> {
        let next_item = self.iterator.next();
        match next_item {
            Some(c) => {
                if c == '\n' {
                    self.location.line += 1;
                    self.location.offset = 0;
                } else {
                    self.location.offset += 1;
                };
                self.location.global_offset += 1;
            }
            None => (),
        };
        next_item
    }
}

/// The lexical analyzer for Diatom
///
/// Note: This lexer assumes that newline character only contains '\n'. Any '\r' is ignored and
/// does not count as a newline.
pub struct Lexer<'a> {
    file_content: &'a str,
    error_reporter: ErrorReporter,
    tokens: Vec<(Token, FileLocation)>,
}

impl<'a> Lexer<'a> {
    pub fn new(file_content: &'a str) -> Self {
        let mut lexer = Self {
            file_content,
            error_reporter: ErrorReporter::new(),
            tokens: vec![],
        };
        lexer.parse();
        lexer
    }

    pub fn has_error(&self) -> bool {
        !self.error_reporter.is_empty()
    }

    /// Parse numeric types, aka int & float.
    fn parse_num(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        fn parse_int(s: &str) -> Result<i64, String> {
            let mut i: i64 = 0;
            if s.starts_with("0x") || s.starts_with("0X") {
                let mut iter = s.chars().skip(2);
                loop {
                    let c = iter.next();
                    match c {
                        Some(c) => {
                            let digit = match c {
                                '0'..='9' => c as i64 - '0' as i64,
                                'a'..='f' => c as i64 - 'a' as i64 + 10,
                                'A'..='F' => c as i64 - 'A' as i64 + 10,
                                _ => {
                                    return Err("Invalid Digit".to_string());
                                }
                            };
                            match i.checked_mul(16) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            };
                            match i.checked_add(digit) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            }
                        }
                        None => break,
                    }
                }
                return Ok(i);
            }

            if s.starts_with("0o") || s.starts_with("0O") {
                let mut iter = s.chars().skip(2);
                loop {
                    let c = iter.next();
                    match c {
                        Some(c) => match c {
                            '0'..='7' => {
                                let digit = c as i64 - '0' as i64;
                                match i.checked_mul(8) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                };
                                match i.checked_add(digit) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                }
                            }
                            _ => {
                                return Err("Invalid Digit".to_string());
                            }
                        },
                        None => break,
                    }
                }
                return Ok(i);
            }
            if s.starts_with("0b") || s.starts_with("0B") {
                let mut iter = s.chars().skip(2);
                loop {
                    let c = iter.next();
                    match c {
                        Some(c) => match c {
                            '0'..='1' => {
                                let digit = c as i64 - '0' as i64;
                                match i.checked_mul(2) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                };
                                match i.checked_add(digit) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                }
                            }
                            _ => {
                                return Err("Invalid Digit".to_string());
                            }
                        },
                        None => break,
                    }
                }
                return Ok(i);
            }

            let mut iter = s.chars();
            loop {
                let c = iter.next();
                match c {
                    Some(c) => match c {
                        '0'..='9' => {
                            let digit = c as i64 - '0' as i64;
                            match i.checked_mul(10) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            };
                            match i.checked_add(digit) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            }
                        }
                        _ => {
                            return Err("Invalid Digit".to_string());
                        }
                    },
                    None => break,
                }
            }
            return Ok(i);
        }
        let mut num = String::new();
        let start = iter.get_location();

        let mut e_flag = false; // Flag for '123e+5' & '123e-4'
        let mut float_flag = false;
        loop {
            let c = iter.peek();
            match c {
                Some(c) => {
                    match c {
                        '+' | '-' if e_flag => num.push(c),
                        '_' => (),
                        '.' => num.push(c),
                        '!'..='/' | ':'..='@' | '['..='`' | '{'..='~' => break,
                        ' ' | '\t' | '\r' | '\n' => break,
                        c => num.push(c),
                    }

                    if c == 'e' || c == 'E'{
                        e_flag = true;
                        float_flag = true;
                    } else {
                        e_flag = false;
                    }

                    if c == '.' {
                        float_flag = true;
                    }

                    iter.next();
                }
                None => break,
            }
        }

        let end = iter.get_location();
        let location = FileLocation::new(start, end);

        if float_flag {
            let float = num.parse::<f64>();
            match float {
                Ok(f) => return Ok((Token::Float(f), location)),
                Err(e) => return Err((ErrorType::InvalidNum(format!("{e}")), location)),
            }
        } else {
            let int = parse_int(&num);
            match int {
                Ok(i) => return Ok((Token::Integer(i), location)),
                Err(e) => return Err((ErrorType::InvalidNum(e), location)),
            }
        }
    }

    /// Parse keyword or Identifier
    fn parse_id_or_key(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        todo!()
    }

    /// Parse string token
    fn parse_string(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        todo!()
    }

    /// Parse operators
    fn parse_op(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        todo!()
    }

    /// Parse all tokens
    fn parse(&mut self) {
        let mut iter = FileIterator::new(self.file_content);
        loop {
            let c = iter.peek();
            match c {
                Some(c) => {
                    let result = match c {
                        '0'..='9' => Some(Self::parse_num(&mut iter)),
                        '"' | '\'' => Some(Self::parse_string(&mut iter)),
                        '\n' => {
                            // generate a newline character
                            let start = iter.get_location();
                            let _ = iter.next();
                            let end = iter.get_location();
                            Some(Ok((Token::NewLine, FileLocation::new(start, end))))
                        }
                        ' ' | '\t' | '\r' => None, // Ignore whitespace
                        _ => Some(Self::parse_id_or_key(&mut iter)),
                    };
                    match result {
                        Some(result) => match result {
                            Ok(x) => self.tokens.push(x),
                            Err((error, location)) => {
                                self.error_reporter.append("Lexer", location, error)
                            }
                        },
                        None => (),
                    }
                }
                None => {
                    break;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_int() {
        fn test_helper(s: &str, i: i64, should_fail: bool) {
            let mut iter = FileIterator::new(s);
            let result = Lexer::parse_num(&mut iter);
            if should_fail {
                assert!(
                    result.is_err(),
                    "Expected parse success! source = {s}, result = {:?}",
                    result
                );
            } else {
                if let Ok((Token::Integer(j), _)) = result {
                    assert_eq!(i, j);
                } else {
                    assert!(
                        false,
                        "Expected parse failure! source = {s} , result = {:?}",
                        result
                    );
                }
            }
        }

        test_helper("1_23", 123, false);
        test_helper("0xf_f", 0xff, false);
        test_helper("0Xff", 0xff, false);
        test_helper("0b1__00011", 0b100011, false);
        test_helper("0o776_610_", 0o776610, false);
        test_helper("999+3", 999, false);
        test_helper("9_223_372_036_854_775_808", 0, true); // Overflow i64
        test_helper(
            "9_223_372_036_854_775_807",
            9_223_372_036_854_775_807,
            false,
        ); // Overflow i64
        test_helper("0x8000000000000000", 0, true); // Overflow i64
        test_helper("0x7fffffffffffffff", 9_223_372_036_854_775_807, false); // Overflow i64
        test_helper("0o1000000000000000000000", 0, true); // Overflow i64
        test_helper("0o777777777777777777777", 9_223_372_036_854_775_807, false); // Overflow i64
        test_helper(
            "0b1000000000000000000000000000000000000000000000000000000000000000",
            0,
            true,
        ); // Overflow i64
        test_helper(
            "0b111111111111111111111111111111111111111111111111111111111111111",
            9_223_372_036_854_775_807,
            false,
        ); // Overflow i64
        test_helper("0xfft", 0, true);
        test_helper("0O999", 0, true);
        test_helper("123y", 0, true);
    }

    #[test]
        fn test_parse_float() {
        fn test_helper(s: &str, i: f64, should_fail: bool) {
            let mut iter = FileIterator::new(s);
            let result = Lexer::parse_num(&mut iter);
            if should_fail {
                assert!(
                    result.is_err(),
                    "Expected parse success! source = {s}, result = {:?}",
                    result
                );
            } else {
                if let Ok((Token::Float(j), _)) = result {
                    assert_eq!(i, j);
                } else {
                    assert!(
                        false,
                        "Expected parse failure! source = {s} , result = {:?}",
                        result
                    );
                }
            }
        }

        test_helper("123e14", 123e14, false);
        test_helper("1_23e_14", 123e14, false);
        test_helper("123E-14", 123e-14, false);
        test_helper("123.", 123., false);
        test_helper("0.01__2", 0.01__2, false);
        test_helper("123e1y", 0., true);

    }

}
