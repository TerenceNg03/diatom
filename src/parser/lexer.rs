use super::error::{ErrorReporter, ErrorType};
use super::util::{FileIterator, FileLocation};

/// A enumerate of all tokens possibly generated by [Lexer][crate::parser::lexer::Lexer].
#[cfg_attr(test, derive(Debug))]
pub enum Token {
    Unknown,
    NewLine,
    Str(String),
    Integer(i64),
    Float(f64),
    Id(String),
    Key(Keyword),
    Op(Operator),
}

/// A enum of all keywords
#[cfg_attr(test, derive(Debug))]
pub enum Keyword {
    TRUE,
    FALSE,
    DO,
    END,
    IF,
    THEN,
    ELSE,
    CASE,
    IN,
    FOR,
    NIL,
    ASSERT,
    RETURN,
    BREAK,
    CONTINUE,
}

/// A enum of all operators
#[cfg_attr(test, derive(Debug))]
pub enum Operator {
    Plus,
    Minus,
    Exp,
    Mul,
    DivFloor,
    Div,
    Mod,
    Range,
    And,
    Or,
    Not,
    GT,
    GE,
    EQ,
    NE,
    LT,
    LE,
    Assign,
    Comma,
}

/// The lexical analyzer for Diatom
///
/// Note: This lexer assumes that newline character only contains '\n'. Any '\r' is ignored and
/// does not count as a newline.
pub struct Lexer<'a> {
    file_content: &'a str,
    error_reporter: ErrorReporter,
    tokens: Vec<(Token, FileLocation)>,
}

impl<'a> Lexer<'a> {
    pub fn new(file_content: &'a str) -> Self {
        let mut lexer = Self {
            file_content,
            error_reporter: ErrorReporter::new(),
            tokens: vec![],
        };
        lexer.consume();
        lexer
    }

    pub fn has_error(&self) -> bool {
        !self.error_reporter.is_empty()
    }

    /// Consume numeric types, aka int & float.
    fn consume_num(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        fn consume_int(s: &str) -> Result<i64, String> {
            let mut i: i64 = 0;
            if s.starts_with("0x") || s.starts_with("0X") {
                let mut iter = s.chars().skip(2);
                loop {
                    let c = iter.next();
                    match c {
                        Some(c) => {
                            let digit = match c {
                                '0'..='9' => c as i64 - '0' as i64,
                                'a'..='f' => c as i64 - 'a' as i64 + 10,
                                'A'..='F' => c as i64 - 'A' as i64 + 10,
                                _ => {
                                    return Err("Invalid Digit".to_string());
                                }
                            };
                            match i.checked_mul(16) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            };
                            match i.checked_add(digit) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            }
                        }
                        None => break,
                    }
                }
                return Ok(i);
            }

            if s.starts_with("0o") || s.starts_with("0O") {
                let mut iter = s.chars().skip(2);
                loop {
                    let c = iter.next();
                    match c {
                        Some(c) => match c {
                            '0'..='7' => {
                                let digit = c as i64 - '0' as i64;
                                match i.checked_mul(8) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                };
                                match i.checked_add(digit) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                }
                            }
                            _ => {
                                return Err("Invalid Digit".to_string());
                            }
                        },
                        None => break,
                    }
                }
                return Ok(i);
            }
            if s.starts_with("0b") || s.starts_with("0B") {
                let mut iter = s.chars().skip(2);
                loop {
                    let c = iter.next();
                    match c {
                        Some(c) => match c {
                            '0'..='1' => {
                                let digit = c as i64 - '0' as i64;
                                match i.checked_mul(2) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                };
                                match i.checked_add(digit) {
                                    Some(result) => {
                                        i = result;
                                    }
                                    None => {
                                        return Err("Integer overflow 64-bits.".to_string());
                                    }
                                }
                            }
                            _ => {
                                return Err("Invalid Digit".to_string());
                            }
                        },
                        None => break,
                    }
                }
                return Ok(i);
            }

            let mut iter = s.chars();
            loop {
                let c = iter.next();
                match c {
                    Some(c) => match c {
                        '0'..='9' => {
                            let digit = c as i64 - '0' as i64;
                            match i.checked_mul(10) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            };
                            match i.checked_add(digit) {
                                Some(result) => {
                                    i = result;
                                }
                                None => {
                                    return Err("Integer overflow 64-bits.".to_string());
                                }
                            }
                        }
                        _ => {
                            return Err("Invalid Digit".to_string());
                        }
                    },
                    None => break,
                }
            }
            return Ok(i);
        }
        let mut num = String::new();
        let start = iter.get_location();

        let mut e_flag = false; // Flag for '123e+5' & '123e-4'
        let mut float_flag = false;
        loop {
            let c = iter.peek();
            match c {
                Some(c) => {
                    match c {
                        '+' | '-' if e_flag => num.push(c),
                        '_' => (),
                        '.' => num.push(c),
                        '!'..='/' | ':'..='@' | '['..='`' | '{'..='~' => break,
                        ' ' | '\t' | '\r' | '\n' => break,
                        c => num.push(c),
                    }

                    if c == 'e' || c == 'E' {
                        e_flag = true;
                        float_flag = true;
                    } else {
                        e_flag = false;
                    }

                    if c == '.' {
                        float_flag = true;
                    }

                    iter.next();
                }
                None => break,
            }
        }

        let end = iter.get_location();
        let location = FileLocation::new(start, end);

        if float_flag {
            let float = num.parse::<f64>();
            match float {
                Ok(f) => return Ok((Token::Float(f), location)),
                Err(e) => return Err((ErrorType::InvalidNum(format!("{e}")), location)),
            }
        } else {
            let int = consume_int(&num);
            match int {
                Ok(i) => return Ok((Token::Integer(i), location)),
                Err(e) => return Err((ErrorType::InvalidNum(e), location)),
            }
        }
    }

    /// Consume keyword or Identifier
    fn consume_id_or_key(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        todo!()
    }

    /// Consume string token
    fn consume_string(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        fn consume_escape(iter: &mut FileIterator) -> Result<char, ()> {
            /// Consume a hex escape sequence with n character exactly
            fn consume_hex_escape(iter: &mut FileIterator, count: u8) -> Result<char, ()> {
                let mut x: u32 = 0;
                for _ in 0..count {
                    x *= 16;
                    match iter.peek() {
                        Some(c @ '0'..='9') => x += c as u32 - '0' as u32,
                        Some(c @ 'a'..='f') => x += c as u32 - 'a' as u32 + 10,
                        Some(c @ 'A'..='F') => x += c as u32 - 'A' as u32 + 10,
                        _ => return Err(()),
                    }
                    iter.next();
                }
                match char::from_u32(x as u32) {
                    Some(c) => Ok(c),
                    None => Err(()),
                }
            }
            let c = iter.next();
            let c = match c {
                Some(c) => c,
                None => unreachable!(),
            };
            match c {
                '\\' => Ok('\\'),
                't' => Ok('\t'),
                'n' => Ok('\n'),
                'r' => Ok('\r'),
                '\"' => Ok('\"'),
                '\'' => Ok('\''),
                'x' => consume_hex_escape(iter, 2),
                'u' => consume_hex_escape(iter, 4),
                'U' => consume_hex_escape(iter, 8),
                _ => Err(()),
            }
        }
        let start = iter.get_location();
        let start_char = iter.next();
        let mut result = String::new();
        let is_single_quote;
        let mut invalid = false;

        match start_char {
            Some('"') => {
                is_single_quote = false;
            }
            Some('\'') => {
                is_single_quote = true;
            }
            _ => unreachable!(),
        };
        loop {
            let c = iter.next();
            match c {
                Some(c) => match c {
                    '\\' => match consume_escape(iter) {
                        Ok(c) => result.push(c),
                        Err(()) => invalid = true,
                    },
                    '\'' if is_single_quote => {
                        if !invalid {
                            return Ok((
                                Token::Str(result),
                                FileLocation::new(start, iter.get_location()),
                            ));
                        } else {
                            return Err((
                                ErrorType::InvalidStr(
                                    "String contains invalid escape sequence.".to_string(),
                                ),
                                FileLocation::new(start, iter.get_location()),
                            ));
                        }
                    }
                    '"' if !is_single_quote => {
                        if !invalid {
                            return Ok((
                                Token::Str(result),
                                FileLocation::new(start, iter.get_location()),
                            ));
                        } else {
                            return Err((
                                ErrorType::InvalidStr(
                                    "String contains invalid escape sequence.".to_string(),
                                ),
                                FileLocation::new(start, iter.get_location()),
                            ));
                        }
                    }
                    c => result.push(c),
                },
                None => {
                    return Err((
                        ErrorType::InvalidStr("String is not terminated".to_string()),
                        FileLocation::new(start, iter.get_location()),
                    ))
                }
            }
        }
    }

    /// Consume operators
    fn consume_op(
        iter: &mut FileIterator,
    ) -> Result<(Token, FileLocation), (ErrorType, FileLocation)> {
        todo!()
    }

    /// Consume all tokens
    fn consume(&mut self) {
        let mut iter = FileIterator::new(self.file_content);
        // Ignore shebang (#!...) at the beginning of the file
        match iter.peek2() {
            (Some('#'), Some('!')) => loop {
                if let Some('\n') = iter.next() {
                    break;
                }
            },
            _ => (),
        }
        // Start consuming characters
        loop {
            // Match some pattern requires 2 lookahead
            match iter.peek2() {
                (Some('-'), Some('-')) => {
                    // Ignore comment
                    loop {
                        let c = iter.peek();
                        match c {
                            Some(c) => {
                                if c == '\n' {
                                    break;
                                };
                            }
                            None => break,
                        }
                        iter.next();
                    }
                    continue;
                }
                (Some('/'), Some('/')) => {
                    let start = iter.get_location();
                    iter.next();
                    iter.next();
                    let end = iter.get_location();
                    self.tokens
                        .push((Token::Op(Operator::DivFloor), FileLocation::new(start, end)));
                    continue;
                }
                (Some('*'), Some('*')) => {
                    let start = iter.get_location();
                    iter.next();
                    iter.next();
                    let end = iter.get_location();
                    self.tokens
                        .push((Token::Op(Operator::Exp), FileLocation::new(start, end)));
                    continue;
                }
                _ => (),
            }
            let c = iter.peek();
            match c {
                Some(c) => {
                    let result = match c {
                        '0'..='9' => Some(Self::consume_num(&mut iter)),
                        '"' | '\'' => Some(Self::consume_string(&mut iter)),
                        '\n' => {
                            // generate a newline character
                            let start = iter.get_location();
                            let _ = iter.next();
                            let end = iter.get_location();
                            Some(Ok((Token::NewLine, FileLocation::new(start, end))))
                        }
                        ' ' | '\t' | '\r' => None, // Ignore whitespace
                        '!'..='/' | ':'..='@' | '['..='`' | '{'..='~' => {
                            Some(Self::consume_op(&mut iter))
                        }
                        _ => Some(Self::consume_id_or_key(&mut iter)),
                    };
                    match result {
                        Some(result) => match result {
                            Ok(x) => self.tokens.push(x),
                            Err((error, location)) => {
                                self.error_reporter.append("Lexer", location, error)
                            }
                        },
                        None => (),
                    }
                }
                None => {
                    break;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_consume_int() {
        fn test_helper(s: &str, i: i64, should_fail: bool) {
            let mut iter = FileIterator::new(s);
            let result = Lexer::consume_num(&mut iter);
            if should_fail {
                assert!(
                    result.is_err(),
                    "Expected parse success! source = {s}, result = {:?}",
                    result
                );
            } else {
                if let Ok((Token::Integer(j), _)) = result {
                    assert_eq!(i, j);
                } else {
                    assert!(
                        false,
                        "Expected parse failure! source = {s} , result = {:?}",
                        result
                    );
                }
            }
        }

        test_helper("1_23", 123, false);
        test_helper("0xf_f", 0xff, false);
        test_helper("0Xff", 0xff, false);
        test_helper("0b1__00011", 0b100011, false);
        test_helper("0o776_610_", 0o776610, false);
        test_helper("999+3", 999, false);
        test_helper("9_223_372_036_854_775_808", 0, true); // Overflow i64
        test_helper(
            "9_223_372_036_854_775_807",
            9_223_372_036_854_775_807,
            false,
        ); // Overflow i64
        test_helper("0x8000000000000000", 0, true); // Overflow i64
        test_helper("0x7fffffffffffffff", 9_223_372_036_854_775_807, false); // Overflow i64
        test_helper("0o1000000000000000000000", 0, true); // Overflow i64
        test_helper("0o777777777777777777777", 9_223_372_036_854_775_807, false); // Overflow i64
        test_helper(
            "0b1000000000000000000000000000000000000000000000000000000000000000",
            0,
            true,
        ); // Overflow i64
        test_helper(
            "0b111111111111111111111111111111111111111111111111111111111111111",
            9_223_372_036_854_775_807,
            false,
        ); // Overflow i64
        test_helper("0xfft", 0, true);
        test_helper("0O999", 0, true);
        test_helper("123y", 0, true);
    }

    #[test]
    fn test_consume_float() {
        fn test_helper(s: &str, i: f64, should_fail: bool) {
            let mut iter = FileIterator::new(s);
            let result = Lexer::consume_num(&mut iter);
            if should_fail {
                assert!(
                    result.is_err(),
                    "Expected parse success! source = {s}, result = {:?}",
                    result
                );
            } else {
                if let Ok((Token::Float(j), _)) = result {
                    assert_eq!(i, j);
                } else {
                    assert!(
                        false,
                        "Expected parse failure! source = {s} , result = {:?}",
                        result
                    );
                }
            }
        }

        test_helper("123e14", 123e14, false);
        test_helper("1_23e_14", 123e14, false);
        test_helper("123E-14", 123e-14, false);
        test_helper("123.", 123., false);
        test_helper("0.01__2", 0.01__2, false);
        test_helper("123e1y", 0., true);
    }

    #[test]
    fn test_consume_string() {
        fn test_helper(s: &str, i: &str, should_fail: bool) {
            let mut iter = FileIterator::new(s);
            let result = Lexer::consume_string(&mut iter);
            if should_fail {
                assert!(
                    result.is_err(),
                    "Expected parse success! source = {s}, result = {:?}",
                    result
                );
            } else {
                if let Ok((Token::Str(j), _)) = result {
                    assert_eq!(i, j);
                } else {
                    assert!(
                        false,
                        "Expected parse failure! source = {s} , result = {:?}",
                        result
                    );
                }
            }
        }

        test_helper(r#""abs__0a™£´∂`'`c\'\"k\n\rkk\x09'""#, "abs__0a™£´∂`'`c\'\"k\n\rkk\x09'", false);
        test_helper(r#"'rrr__0a™£´∂`"`c\'\"k\n\rkk\u00E9"'"#, "rrr__0a™£´∂`\"`c\'\"k\n\rkk\u{00E9}\"", false);
        test_helper("'\\xaz'", "", true);
        test_helper("'\\u@0'", "", true);
        test_helper("'\\U0000fFFf'", "\u{ffff}", false);
        test_helper("'\\ufFff'", "\u{ffff}", false);
        test_helper("'\\UdFFf'", "", true);
        test_helper("'\\uDfff'", "", true);
        test_helper("'", "", true);

    }
}
